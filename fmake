#!/usr/bin/env perl
#
# fmake
#  analyze dependecy file of current directory c++/c/cu file and compile them
#  
use strict;

our $exeExt="";
our $depExt="dep";

# C++ : .cpp or .cc
our $cxx = "g++";
our $cxxflags = "-Wall -O2";
our $cxxlibs  = "";

# C :.c
our $c = "gcc";
our $cflags = "-Wall -O2";
our $clibs  = "";

# nvcc (CUDA) :.cu
our $nc = "nvcc";
our $narch="-arch sm_50";
our $ncflags = " $narch -Xcompiler '-O2 -g' -Xptxas=-v";
our $nclibs  = "";


#=============================================================
# main
#=============================================================
my $cleanFlag = 0;
if (@ARGV == 1){
    if( $ARGV[0] eq "clean"){
        $cleanFlag = 1;
    }
}

my @fileList = glob( "*.cpp *.c *.cu" ); # get file-list

if($cleanFlag==1){
    print "remove :";
    foreach my $in  (@fileList){
        my ($out, $ext) = splitFileName($in);
        $out=$out.$exeExt;
        my $dep = $out.".${ext}${depExt}";
        unlink $out;
        unlink $dep;
        print " $out $dep";
    }
    print "\n";
    exit(0);
}

my $lengthOfFileList = @fileList;
my $counter = 1;
foreach my $in  (@fileList){
    my ($out, $ext) = splitFileName($in); # basename and file extension
    $out=$out.$exeExt;
    my $dep = $out.".${ext}${depExt}"; # depfile name
    

    print "[$counter/$lengthOfFileList] $in";
    $counter = $counter + 1;

    if( ( ! -e $dep ) || ( isUpdated($out,$dep)) ){
        print "\n";
        if( $ext eq "cpp" || $ext eq "cc" ){ # C++
            exeCommand_cplusplus($in,$out,$dep);
        }elsif ( $ext eq "c" ) {             # C
            exeCommand_c($in,$out,$dep);
        }elsif ( $ext eq "cu" ) {            # NVCC(CUDA)
            exeCommand_nvcc($in,$out,$dep);
        }else{
            print "ignore\n";
        }
    }else{
        print "\t: no work to do.\n";
    }
}
 system_without_stderr_stdout("ls>foo.txt");   
#=============================================================
# submodules
#=============================================================

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#bool exeCommand_cpp(in,out,dep)
# exec command for c++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub exeCommand_cplusplus{
    my $in =  $_[0];
    my $out = $_[1];
    my $dep = $_[2];
    system_printCommand("$cxx -MMD -MF $dep $in -o $out $cxxflags $cxxlibs")==0 or return;#error
    return 1;
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#bool exeCommand_c(in,out,dep)
# exec command for c
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub exeCommand_c{
    my $in =  $_[0];
    my $out = $_[1];
    my $dep = $_[2];
    my $command = "$c -MMD -MF $dep $in -o $out $cflags $clibs";
    system_printCommand("$c -MMD -MF $dep $in -o $out $cflags $clibs")==0 or return;#error
    return 1;
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#bool exeCommand_nvcc(in,out,dep)
# exec command for nvcc
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub exeCommand_nvcc{
    my $in =  $_[0];
    my $out = $_[1];
    my $dep = $_[2];
    system_without_stderr_stdout("$nc -M $in $ncflags $nclibs > $dep")==0  or return;#error
    system_printCommand("$nc -o $out $in $ncflags $nclibs")==0   or return;#error
    system_without_stderr_stdout("$nc -cubin $in $ncflags $nclibs && cuobjdump -sass $out.cubin >| $out.sass")==0  or return;#error
    system_without_stderr_stdout("$nc -ptx $in $ncflags $nclibs")==0  or return;#error
    return 1;
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# bool splitFileName(string filepath)
#  return (filepath(without extension) , file-extension)
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub splitFileName{
    my $out = $_[0];
    $out =~ s/\.[^\.]*$//;
    my $ext = $_[0];
    $ext =~ s/.*\.([^\.]*$)/$1/;
    return ($out,$ext);
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# system_without_stderr_stdout(string command)
# exec system command hiding stdout and stderr
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub system_without_stderr_stdout{
    my $command = $_[0];
    open my $oldout, ">&STDOUT";
    open my $olderr, ">&STDERR";
    close STDOUT;
    close STDERR;

    my $res = system( $command );

    open STDOUT, '>&', $oldout;
    open STDERR, '>&', $olderr;
    
    return $res
}

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# bool system(string command)
#  system(command) and print command
#  return : value of system(command)
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub system_printCommand{
    my $command = $_[0];
    print $command,"\n";
    return system($command);
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# bool isUpdated(string executionFilename, string Depfilename)
#   if executionFilename was updated then return 1;
#   else 0
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub isUpdated{
    my $filename = $_[0];
    my $mtime = mtime($filename);

    my $depfilename = $_[1];

    open(DATAFILE, "< ".$depfilename) or die("file open error");
    my $deps="";
    while(my $line = <DATAFILE>){
        $line =~ s/\\\n//mg;
        $deps = $deps.$line;
    }
    close(DATAFILE);
    $deps =~ s/.*:\s*//;
    my @strlist = split(/\s+/, $deps);

    foreach my $s  (@strlist){
        my $depmtime = mtime($s);
        if ( $mtime lt $depmtime ){
            return 1;
        }
    }

    return 0;
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# string mtime(string filepath)
#   return mtime
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub mtime{
    my $filename = $_[0];
    my @filestat = stat $filename;
    my ($sec, $min, $hour, $mday, $mon, $year)= localtime($filestat[9]);
    $year = $year + 1900;
    $mon= $mon + 1;
    return sprintf("%04d%02d%02d%02d%02d%02d", $year, $mon, $mday, $hour, $min, $sec);
}